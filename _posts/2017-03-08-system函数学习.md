---

layout: post

title: 'system函数的深入理解'

date: '2017-02-28'

header-img: "img/home-bg.jpg"

tags:
     - linux
author: 'De4dCr0w'

---

在学习Return-to-libc攻击方法时运用到了system函数，很好奇system具体是怎么实现的，所以在这里具体看一下：  
### 基本知识 ###
#### fork函数 ####
fork函数通过系统调用创建一个与原来进程几乎完全相同的进程，一个进程调用fork函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。  
* 在父进程中，fork返回新创建子进程的进程ID  
* 在子进程中，fork返回0  
* 如果出现错误，fork返回一个负值  

>其实就相当于链表，进程形成了链表，父进程的fpid(p 意味point)指向子进程的进程id, 因为子进程没有子进程，所以其fpid为0.

### system源码 ###

	#include
	#include
	#include
	#include
	int system(const char * cmdstring)
	{
	  pid_t pid;
	  int status;
	  if(cmdstring == NULL){
	     
	      return (1);
	  }
	  if((pid = fork())<0){
	
	        status = -1;
	  }
	  else if(pid == 0){
	    execl("/bin/sh", "sh", "-c", cmdstring, (char *)0);
	    -exit(127); 
	    }
	  else{
	        while(waitpid(pid, &status, 0) < 0){
	          if(errno != EINTER){
	            status = -1;
	            break;
	          }
	        }
	    }
	    return status;
	}

根据代码我们可以知道system函数的处理过程。当命令参数为NULL时返回1，如果不为NULL，则fork一个子进程,fork失败则返回-1。如果成功，就调用execl，路径是"/bin/sh"，一般这个会软链接到bash上，所以子进程就变成了一个shell进程。如果调用/bin/sh失败时返回127，成功调用后返回shell命令后的返回值但是此返回值也有可能为system()调用/bin/sh失败所返回的127，因此最好能再检查errno 来确认执行成功。  
在调用system()期间SIGCHLD 信号会被暂时搁置，SIGINT和SIGQUIT 信号则会被忽略。


参考文档：[http://blog.csdn.net/yankai0219/article/details/6730121](http://blog.csdn.net/yankai0219/article/details/6730121)
